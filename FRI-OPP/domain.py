from algebra.finite_field import *
from linearized_polynomials import *
import itertools 

"""
Here we define DomainIerarchy - crusial structure for the whole FRI-OPP protocol.
DomainIerarchu is a seriels of subsets (we call subset D_i the i-th level of the domain_ierararchy) of some finite field F_q, posessing good algebraic structure - 
(multiplicatibve or ) and sequence suitable surjective maps q_i from 
Those maps q_i respect the algebraic structures of those domains in the sense, if
"""

class DomainIerarchy():
    def __init__(self):
        pass

    #get the size of the i-th lebel:
    @abstractmethod     
    def get_domain_size(self, i):
        pass

    #check if point p belongs to the i-th level of iera
    @abstractmethod
    def is_in_domain(self, p, i):
        pass

    #assuming point p belongs to the i-th domain, get its image in the i+1 - domain,
    #which is equal to q_i(p)
    @abstractmethod
    def map_to_subdomain(self, val, i):
        pass

    #assuming point p belongs to the i-th domain, return the corresponding coset of this point,
    #which are all points in the domain 
    @abstractmethod
    def get_coset(self, val, i):
        pass

    @abstractmethod
    def coset_iter(self, i):
        pass

    @abstractmethod get_preimage


class MultiplicativeDomainIerarchy(DomainIerarchy):
    def __init__(self, field, size, levels, nu = 2):
        if field.is_extension_field:
            raise StarkError("Multiplicative domain can be constructed only for residue fields.")
        group_order = field.get_num_of_elems() - 1
        if (group_order % size):
            raise StarkError("There is no multiplicative domain of size %d in %s.", %(size, field))
        if size % (nu ** (levels - 1)) != 0:
            raise StarkError("Specified size is to small to construct required number of levels")

        mul_gen = field.get_prim_element()      
        omega = mul_gen ** (group_order / size)

        w = omega ** (size / nu)
        self.coset_gen = [w**k for k in xrange(nu)]

        self.field = field
        self.size = size
        self.levels = levels
        self.nu = nu
        self.omega = omega
   
    def is_in_domain(self, val, i):
        return val ** (self.size / (self.nu ** i)) == 1

    def map_to_subdomain(self, val, i):
        return val ** self.nu

    def get_coset(self, val):
        return [val * w for w in self.coset_gen]     
        
    def get_domain_size(self, i):
        return self.size / (self.nu ** i)

    def coset_iter(self, i):
        level_omega = omega ** (self.nu ** i)
        return (self.get_coset(level_omega ** i) for i in xrange(self.get_domain_size(i) / self.nu))


class AdditiveDomainIerarchy(DomainIerarchy):
    """
    Given linear independent spanSet [e_1, ..., e_n] computes series of subspace polynomials vanishing exactly over the subspaces
    generated by (e1), (e1, e2), ... , (e1, e2, ..., e_m). If [e1, .., e_n are not linearly independent] returns None
    NB: our algoruthm only works for fields of characteristics 2

    For simplicity, let us first describe an alg that would work assuming {e1,..ek} are lin. independent:
	The algorithm would inductively computes the (coeffs of the) subspace polynomial P_i of the subspace spanned by {e_1,..,e_i}.
	For i=1, this is the polynomial x^2 + e1*x. Assume we have computed P_{i-1}.
	* it turns out that P_i is P_{i-1} composed from the outside with x^2 + P_{i-1}(e_i)*x
	* this is the formula the code implements.
	All this was assuming {e1,..,ek} were linearly independent.
	Now, to remove this assumption, before constructing the next P_i we check if the current e_i is linearly dependent
	on {e1,..,e_{i-1}} - we do this by simply checking if P_{i-1}(e_i) =0.
	If so, we simply let P_i= P_{i-1}.
	Otherwise, we derive P_i using the formula described above.
    (This algorithm is taken from libstark implementation)
    Note, that thus constructed subspace polynomial is linearized
    """
    @classmethod
    def _construct_successive_subspace_polys(cls, spanSet):
        #some initial checks and definitions
        assert(len(spanSet) != 0, "Spanning set of subspace is empty!")
        field = spanSet[0].__class__
        assert(hasattr(field, "char") and field.char == 2, "Subspace polynomial creation algorithm is valid only for fields of char 2")
        poly_ring = LinearisedPolyRing(field)
        res = []

        #initializing as the subspace poly of the space {0} - which is x
        poly = poly_ring([field(1)])
        for elem in in spanSet:
            #compute c= P_{i-1}(e_i)
            c = poly.evaluate(elem)
            if c == field(0):
                return None

            basis.append(elem)          
            poly = poly.frobenius_morphism() + poly.multiplyByConstant(c)
            res.append(poly)
        return res

    """
    Given spanset = [e1, e2, ..., e_n] we assume that the first domain is generated by
    [e1, e2, ..., e_(n - nu)], the second by [e_1, e_2, ..., e_(n - 2*nu)] and so on
    """
    def __init__(self, spanSet, levels, nu = 1):
        if (len(spanSet) <= levels * nu)
            raise StarkError("Specified size is to small to construct required number of levels")
        subspace_polys =  self._construct_successive_subspace_polys(spanSet)
        if subspace_polys is None:
            raise StarkError("Provided spanning set is not linear independent")
        
        self.basis = spanSet[::-1]
        self.subspace_polys = subspace_polys[::-nu][:levels]
        self.p = 2
        self.levels = levels
        self.nu = nu
       
    def get_domain_size(self, i):
        basis_len = len(self.basis) - i*nu
        return self.p**basis_len

    def is_in_domain(self, val, i):
        return self.subspace_polys[i].evaluate(val) == 0

    def _q_basis_generator(self, i):
        y = (reduce((lambda c, (j,y): c + self.basis[nu * i + j] * y), enumerate(x), 0) for x in itertools.product(xrange(self.p), repeat = nu))

    def map_to_subdomain(self, val, i):
        #returns product of (val - x) for all x in subspace generated by [e_(nu *i), ..., e_(nu*(i+1) - 1)]
        return reduce((lambda x, y: x * (val - y)), self._q_basis_generator(i), 1) 
 
    def get_coset(self, val, i):
        return [val + x for x in self._q_basis_generator(i)]

    def coset_iter(self, i):
        coeffs = itertools.product(xrange(self.p), repeat = len(basis) - i - 1)
        disjoint_representatives = (reduce((lambda c, (j,y): c + self.basis[-j-1] * y), enumerate(x), 0) for x in coeffs)
        return (self.get_coset(x) for x in disjoint_representatives)











